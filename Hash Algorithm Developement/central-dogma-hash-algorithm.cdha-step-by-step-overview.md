---
id: w967b9mitlhgdmv3n57aqf3
title: Cdha Step by Step Overview
desc: ''
updated: 1669859985415
created: 1669850683205
---

# Step-by-Step Overview of Central Dogma Algorithm
- Let $s$ be the input string and $h$ be product string of the intermediate steps as well as the output hash with $256$ characters.
- The string $s = ``password"$ will be used in the running example.

## Step 1: Convert the Input String to a Decimal String
- Each character of the input string $s$ is converted into its ASCII decimal representation and then remapped to a unique $12$-$14$ digit number (_See **Table S1** in the Supplementary Materials for Proof_) using the formula below. 
    - $$remapASCII(L_0L_1L_2) = \lfloor \frac{\lfloor \frac{(L_0+3)^{10} + (L_1+3)^{10}}{3} \rfloor}{L_2+3} \rfloor ^3 \text{ mod } 10^{14}$$
    - where $L_0L_1L_2$ are the digits in the decimal representation of the ASCII character
    - if the decimal representation for the ASCII character is:
        - two digits a leading zero is added
        - single digit two leading zeros are added

    **<u>Note:</u>**
    - We only care about the $95$ printable characters of ASCII which have decimal representations from $32$-$126$

    - _eg._ $h = 104$

    $$
    \begin{align}
    remapASCII(L_0L_1L_2) &= \lfloor \frac{\lfloor \frac{(L_0+3)^{10} + (L_1+3)^{10}}{3} \rfloor}{L_2+3} \rfloor ^3 \text{ mod } 10^{14} \\
    remapASCII(104) &= \lfloor \frac{\lfloor \frac{(1+3)^{10} + (0+3)^{10}}{3} \rfloor}{4+3} \rfloor ^3 \text{ mod } 10^{14} \\
    &= 32843155141000 \\
    \end{align}  
    $$
- The remapped numbers are then concatenates together in intermediate decimal string $h$.

**Running Example:**

$h = 32843155141000~76310579997029~67192309327341~67192309327341~97686610171064~37538474618728~95925546284544~64000460137509$


## Step 2: Partition the Decimal String and Recombine it
- The intermediate decimal string $h$ is treated like an array then partitioned into two strings: $h_{even}$ and $h_{odd}$.
    - $h_{even}:$ concatenates the digits with an even index
    - $h_{odd}:$ concatenates the digits with an odd index

$$
\begin{align}
h &= h_0h_1...h_n \\
h_{even} &= h_0h_2...h_{2k} \quad (\text{where }k \in \mathbb{N}) \\
h_{odd} &= h_1h_3...h_{2k+1} 
\end{align}
$$

- The two strings $h_{even}$ and $h_{odd}$ are added together using integer addition to create the decimal string $h = h_{even} + h_{odd}$.

**Running Example:**

$$
\begin{align}
h_{even} &= 38351107307972612037461203749661116358768299542446006170 \\
h_{odd} &= 38351107307972612037461203749661116358768299542446006170 \\
h &= h_{even} + h_{odd} \\
&= 62505113467882405960640596067521821093186152110990046529 \\
\end{align}
$$

## Step 3: Expand and Discard Segments of the Decimal String
- This following steps will be repeated $3$ times:
    - **Step 3.1:** The intermediate decimal string $h$ will be cubed $m \in \mathbb{N}$ times till it is greater than $10^{3072}$.
        - $h^{3^m} > 10^{3072}$
    - **Step 3.2:** The resulting string $h^{3^m}$ will be treated like an array then partitioned as follows:
        - $h_{odd} = h_1h_3...h_{3071}$
        - $|h_{odd}| = 1536$ 
    - **Step 3.3:** The resulting decimal string $h_{odd}$ will be processed as follows:
        - If $h_{odd}$ has a substring that start and end with the following sequence of even and odd digits then that substring will be removed from $h_{odd}$ if and only if the resulting string has a length greater than or equal to $14$.
            - Let $o$ be an odd digit and $e$ be an even digit
            - **Start:** $oeeo$
            - **End:** $eeoe$
        - These segments will be removed in the order they appear as long as the resulting string has greater than or equal to $14$ digits.
        - eg. 
            $$
            \begin{align}
            h_{odd} &= 9oeeo...eeoe944oeeoeeoe44 \\
            h_{odd}' &= 9944oeeoeeoE44 \\
            \end{align}
            $$


            **<u>Note:</u>**
            - The segment between the $9$'s are removed as the resulting string will have at least $14$ digits.
            - The segment between the $4$'s are not removed as the resulting string will not have more than $14$ digits.
    - **Step 3.4:** The final $h'_{odd}$ string will be fed back into **Step 3.1** as $h$.
- <span style=color:aquamarine;background:none>**_Biological Inspiration:_**</span> In the central dogma, premature mRNA is converted into mature mRNA by slicing out the introns (non-coding region of mRNA) and joining the ends of the exons (coding mRNA that is translated/converted into aminoacids). Introns have a specific start and end sequence. The $GU$ dentoes the start of the intron and $AG$ denotes the end of the intron. We used this biological mechanism in our algorithm to remove sections of our decimal string. We converted the intron's start and end sequences to binary using our bit string to mRNA base mapping (See Table in **Step 6**). From there the binary sequence was mapped into a sequence of even and odd numbers where each $1$ would be an odd number and each $0$ would be an even number.
- <span style=color:deeppink;background:none>**_Property of Hash Algorithm:_**</span> In this step of the algorithm information about the original string $s$ is loss through partioning $h$ and keeping only $h_{odd}$ as well as the removal of sections of $h_{odd}$. This is one of the features that makes the algorithm a **one-way** function.

**Running Example:**
### Step 3.1 - Iteration 1
 $h^{3m} = 29455023955971493158465506934887152225679882040403369047734860409397579977655858696435267026189383154770134334940889933119714592433362258304052591901010799907752029494601666188946434633881549401483032437477561266749273315741430220752615387667903957596530897306047733108657179462654522835793038684939343849636028599728384327075643868015921389978750941459707919654800485557948170629553334315725716509129141259229295332436878614794207247684895891772616147374237671020627920388280347959243407295658572523346958519543481347161937863366201410973694775717399660805234508819014595374738089602800414796480180541913850223120940334177054992209276510713981599474392140023271095413481019784743141834628712250780989813105866141615319097237770251106679077318912580285348825468290886900231934153704704137271818400684468965365466492395923664743833184056043459211057604139268448562698969103054055043508489642419886724000769345693652771107691667665855049413957279205437390396266396964857738579147880080600795125698959096506868080068787943284269950748492060959738556278087121196565821011045331314540100664135462082863619381329721955756140109689620118803138160990001471389255921198128778875481710531363334819682704922814837708174910679365438996029050509882467059779745842436586020811394348018051406344616875015823424710446954888998111087072801990286445995739188204166949145873143585578600535395985856272996073770630377148337301125263827686416804729534861350553882234253910757097207632337676231611075376112595311231410414281292127114249619384988367406889075994544867079400112927214599888588341638011260940022817969764664657271114513666039109750507045178590361094321875168841983242625105058970664935301392478446515942755275516524973986345022401942543433958724720834924698753988053934838258587464681873968887278185723319454866451434958555939647726227538554840425735942341205665387646631693160477913902093578420712502834389407425880465773682456227033144809264545735050107607935692969055584473505022715669348949467083285118787771947451094841000866398899912310088172630890206394873442572299693397617771241366585206880090953770055417604001183941391026106370633267861031356571116857016850813673545463394597091081355428173528750373535794206373579021595606273895306860128850924240236492794198121832810299933905352505506237319866811520785186154966560196479444501311722272339716889498906465768848947674206797443127286643778494672278630131992012530460970237208882648121071163863496614069034379397768279474086157327925270861544077071028172057836868463588176277597839797864483099598637183468833180464817099963410653680839264615460971992509779313112311695708435155696242234105953683861700281230978740545707765176171054334924746425193465137708055618602581130697929778211025602660135600584042848555752749546744923012260117295946255851919148700627456424942125836708809435740815127652332832052585857152302394742155468922711258198023080130888138412228138963757476837833866413510551090614471235705392918873167319680031308218054816194556094969162021341357263359627989062400802563805386068505068577058716771197717186362004662677405334334554162319301822179006465528885727548200724501370501454748421692155937232190768341561520733191601517163625624305226272420096140658910505174297685377053303138812477684752145338883691930725115093103293438185252670069750563254853026384964352660358741004681994182841422432825082734464867191567767552064931922721018163596702845867191510084876109617710995945122158266523067466063877150880928102772634351463368510992329565295659334752458038211090018395223676053190220005653822685160021482048223011270768300552276268330746366984032558168673513887310609689563831887027410179683304795036012340109466120395297179638792166149615633659639934621096148569620391802476290107602748167834686295518736677178053941128687926454260778737550256078545011828186558950430935745246234643494412680061498067371668897999602492681430302474217096036141668987880912991255826922214223962319402821832440188174029608776739762685185946824032729894300129866012717449134637297351119833426382086445690461385947498299319966658908440440087544416968017131730196778473608878564853758179223873106015486817907257216097251240317632184036483190754744733953241792850157028636968678659915486582260724319240571085806799794328084489879196194359792452093293951625506652240056969531298796121192211446496852829850319895207283262122145106438107237456586290334029286301607978301118508420298314084176875628728699216236232797140030167067428647347272155086032105135565635631735628900292929$

### Step 3.2 - Iteration 1
$h_{odd} =  950359191865638752578244360738003779758894560683357033448931915233253455100099750996161844438144180234762642317132056586709795093647306774255237336433346625923420548819189859157716404559876953417515921152993238817402788597211772770029082049944796875349815383769763604076477796002408915577886204494085118021043470492975019194491022194380987348427257088308646510737051670719282548562089039457401778806469564693526448380644910701964866861350545886218620063596271796768544352904793663668735948086091599995660067742469044269935670721668110533441061560266983929551006921801869004182521827874115163416209218701416964890955984757948235628193810103418518327049489810778192649531801641571385805599552290376071833122326618425463058232317792733772110571293134012191712913483708979448774019715985846812040219966452115360907000575060428568182221559069503274619252515479640209244357428426859859432884488368771523958654455536722735444539242563746191079300374015233904584576252731402447551709599955475527563844782517779750440063899210876092698345296396772165508099370516401343121676368133671650658375563490183521327075592675925502393661859442697491138099303205633968127581465094945117273918999667849772694322647896276039215069032886820168396460473762970653722065470121258664381675737764395831368384410964056032414079207911216504556642409388102139845507571153427621361700516281099972126261505448857245649312012542559947024629228608937011753230288753297254827151820038834221867778738615050014137599871716033810411450461223152356780208268580800870817197783$

### Step 3.3 - Iteration 1

$h'_{odd} = 9503591907380037797762642317197950936473067742552373364333466259234205488191898591577164045598769534175159211529932859721177277002908204947779600240891557788620449408511802975019194491022194570883086465107370516707192823945064491070196486686135054588621862006354352904794426993567072166811053392955100692047411516341620921870141696489095589810778192649533760718334231779273377211057129310402199664521158182221559069503274619252515479640209244357428426859859432884488455536722735444539242563452517779750440063893755634901835213270755926759255023933949451172739189932264783288682070121258664381675737441096400792079112165045566424092136170051628109997212626150544885542559947024629228608937011753230288753297254827151820067778738615023152356780208268580800870817197783$

$...$

### Final Output of Step 3
$h = 621277331570374465702733536540608552121632203715247930621120556277193294597028280896220303206223330600804650551612725302043850342033389982345286707618137721470171983743492990605596762514875359000684408987167456135964067005307200286974666804612681968201957283666821527748119833529750837969048026206503477469251668824582610358629226428675965553509204829653611351315166264525937804844281971519345924264956300938549171872743556257718775480277358738113124230586089398301354904755326666068903585726622128051929974545369199929943513803108910359331315365806928001071505846891380238382609771734097142836605753676597944291470748792204740259670135166210800126073571206759454940379719505329387782291774946394570334$

## Step 4: Expand Decimal String to Desired Length
- The decimal string $h$ will be cubed $m \in \mathbb{N}$ times till it is greater than $10^{3072}$.
    - $h^{3^m} > 10^{3072}$
- The resulting string $h^{3^m}$ will be segmented as follows:
    - $h = h_0h_1...h_n$
    - $h_{odd} = h_1h_3...h_{3071}$
    - $|h_{odd}| = 1536$ 

- <span style=color:deeppink;background:none>**_Property of Hash Algorithm:_**</span> 
    - In this step of the algorithm information about the original string $s$ is loss through partioning $h$ and keeping only $h_{odd}$ as well as the removal of sections of $h_{odd}$. This is one of the features that makes the algorithm a **one-way** function.
    - This step of the algorithm also ensure that the digest is of a **fixed length** by partioning $h$ and keeping only $h_{odd}$ of a certain length.


**Running Example:**
$h = 391849729260302623451521300865839200874071563738281503557438024950746543896717699036673573439621639619001242113433425118980562412709900233298831857654199285723533019121895291320074144176440369963229138731745878017510169794324568743258826464559717094996452765863757432946569826848625362980203054332205968011357581323451558702787011546405760577103681357165619286050174330924335018643800411161897623161923033915721545278184522292113961541193104212475126747850454903882656401479768789686504699021710663958424456231860047792168484419255698540172076674251469981593799676268938316054108672067439487993989491147073695112796526386066779180558735363173987309558851155245945346644674364251847763132003186344826623795222434962384938471554989776357711012717139132583485256174773141177288011716232924839159431975951356805171104993617772297210494022670691792486829193494239297153489520805176504290692380547866649124698179108496187659538562083399339471925083562494909141127937642710589574082709936348898953643251772619697102474624854058832264633183807824295511288951554932764122751114218742876841988070177760516991049879447048134910284948207180945724370121313579144878819454076979945673538908240425263641591254704699032069213322191500506172050224843871329508627042605670988007163334891708555394176061823358052105496434433917963662656695370967542421796466348330916147522912204796073650785209742241610987036056384703454559388252536739777706003907460922199823502288649113964159479744927191172367102610390152231458835235175463495921042796874427622285132431$

## Step 5: Convert Decimal String into Bit String with the same number of Digits
- The decimal string $h$ is converted into a bit string as follows:
    - If a digit in $h$ is even it will be replaced with $0$.
    - If a digit is $h$ is odd it will be replaced with $1$.
    - eg.
        - $h = 01654 \Rightarrow h' = 01010$
- <span style=color:deeppink;background:none>**_Property of Hash Algorithm:_**</span> In this step of the algorithm information about the original string $s$ is loss through grouping of even and odd numbers in its conversion to binary. This is one of the features that makes the algorithm a **one-way** function.

**Running Example:**
$h = 111001101000100001011101100001011000010011101110001101111010000110100101010111011010011111011001011011001000111011001110100100010101100011010011011010111001101111011101011011100010100110000101101001110111101010011110101110100100101010000000111111010110010101001111010100101000000001100100001010110001100011111101101011110100101011100001100111101001111101011000010110110100111010001000011101011001101101011111101101010100100010111101101111100010011100101010010101000010001011100101000100011001110001110000010011000001110100000011011010100110010010011001101111111010000110110010100010001011001111101011101011011110110100100000111100110111101111101101110011111001101100000010100011001101110001100100000001111000010100100110011110101110111111010111111110101001010110111101111000011110010100011111011111111110001111100111011110011010010000010011110000001111010011011111001100001110100010010100101000001100010111100010101011110100001111111011101001100010101101101111000110101110000101110100010111001011110011011100010000010010010000011101001000011111000111110110100100111110010100010001100010111100110111001011001000110110000100001100101100110101111111100010011010010111101011110100000001001001111010100011010001011100111100100110010000001011101100001000001010100001101110011100111110110001001110010101010010011111101000010011110101100001110000100110110101100110000110011010101001100001010101010010100101010111100010110111111100001101000100111001100000001111100111011100101111110101100010110110011010011011111001011101000110010001000001110011$

## Step 6: Convert Bit String into mRNA String
- The bit string is remapped using the following table:

2-bit string | RNA base
:-----------:|:--------:
$00$ | $A$
$01$ | $U$
$10$ | $G$
$11$ | $C$

- <span style=color:aquamarine;background:none>**_Biological Inspiration:_**</span> In the central dogma, mRNA is consists of $4$ base pairs: adenine (`A`), cystosine (`C`), uracil (`U`), and guanine (`G`). We drew inspiration from these mRNA bases to encode our binary string using the mapping in the table above.

**Running Example:**

$h = CGUGGAGAUUCUGAUUGAUACGCGACUCGGAUGGUUUUCUGGUCCUGUUGCAGACGCACGGUAUUUGACUACUGGCGUGCCUCUUGCGAGGUGAUUGGUCUCGGGUCGGCGGUAGGGAAACCCUUGUUUACCUUAGGAAAUGUAAGGCAUGACCCUGGCCUAGGCGAUGUCGGUCCUUGAUUGCUACGGAGAUCUUGUGCUUCCGCUUUAGAGCCUGCCGAGUCAGGGUUUAAGAGCGUUAUAUGUCAUCAAUACAAUCUAAACUGGGUGUAGUGUGCCCGGAUGCAGGAGAGCACCGGCGGCUCGCUAGAACCACUCGCCGCUCACCGUGCAAAGGACACUCAUGUAAAUCGAUUAGUGUCGGCGCCCUUCCCGGGUUUGCCUCGAUCGUUAUCCUCCCCGACCGUCUCGUGGUAAUACCAAACCUACUCCACAACGGAGUUAGGAACAUUCGAGGGCCUAACCCGCGGUGAGGCUGCCAUGGCGAUUCUAUUCAGCCACUCAUAAUAGUAAUCUAGAUCCAUCCUGGUACCGUUAUAUGAGCCACUCAGCAGACUGAUAACAGCACUUCCCGAGUGGUUCGGCCUAAAUAGUCGGGACUAUUCACCAGUGUAAAGCGCAAGAAGGGAUGCGUCACCGCAUACGUUUUAGUCCGGAUACCUUGAUCAAGUGCUUGUGAUGUGGGGUGAUUUUUAGGUUUUCGAGCUCCCAACUAUACGUGAAACCGUCUCAGCCCUUGAGCUGUGGUGCCGUUCUAUGUAUAAUCAC$

## Step 7: Convert mRNA String to Amino Acid String
- The mRNA string will be remapped using the following table:

Amino Acid | RNA Codon
:---------:|:---------:
$A$ | $GCU, GCC, GCA, GCG$
$L$ | $CUU, CUC, CUA, CUG, UUA, UUG$
$R$ | $CGU, CGC, CGA, CGG, AGA, AGG$
$K$ | $AAA, AAG$
$N$ | $AAU, AAC$
$M$ | $AUG$
$D$ | $GAU, GAC$
$F$ | $UUU, UUC$
$C$ | $UGU, UGC$
$P$ | $CCU, CCC, CCA, CCG$
$Q$ | $CAA, CAG$
$S$ | $UCU, UCC, UCA, UCG, AGU, AGC$
$E$ | $GAA, GAG$
$T$ | $ACU, ACC, ACA, ACG$
$E$ | $GAA, GAG$
$W$ | $UGG$
$G$ | $GGU, GGC, GGA, GGG$
$Y$ | $UAU, UAC$
$H$ | $CAU, CAC$
$V$ | $GUU, GUC, GUA, GUG$
$I$ | $AUU, AUC, AUA$
$\_$ | $UAA, UGA, UAG$

**<u>Note:</u>** There are $20$ different amino acids plus $1$ nonsense codon thus there are $21$ possible characters that can be used in the hash.

- <span style=color:aquamarine;background:none>**_Biological Inspiration:_**</span> In the central dogma, mature mRNA is translated/converted into amino acids $3$ bases at a time based on the RNA codon ($3$ base sequence) the bases form. We drew inspiration from these mRNA codons to encode our mRNA string using the mapping in the table above.
- <span style=color:deeppink;background:none>**_Property of Hash Algorithm:_**</span> In this step of the algorithm information about the original string $s$ is loss through the degenarcy of the genetic code (some amino acids are mapped to by more than one mRNA codon). This is one of the features that makes the algorithm a **one-way** function.

**Running Example:**

$h = RGDSD\_YATRMVFWSCCRRTVFDYWRASCEVIGLGSAVGKPLFTLGNVRHDPGLGDVGP\_LLRRSCASALEPAESGFKSVICHQYNLNWV\_CARMQESTGGSLEPLAAHRAKDTHVNRLVSAPFPGLPRSLSSPTVSW\_YQTYSTTELGTFEGLTRGEAAMAILFSHS\_\_\_SRSILVPLYEPLSRLITALPEWFGLNSRDYSPV\_SARRDASPHTF\_SGYLDQVLVMWGDF\_VFELPTIRETVSALELWCRSMYNH$
